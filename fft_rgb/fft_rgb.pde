/**
 * This sketch demonstrates how to use an FFT to analyze
 * the audio being generated by an AudioPlayer.
 * <p>
 * FFT stands for Fast Fourier Transform, which is a 
 * method of analyzing audio that allows you to visualize 
 * the frequency content of a signal. You've seen 
 * visualizations like this before in music players 
 * and car stereos.
 * <p>
 * For more information about Minim and additional features, 
 * visit http://code.compartmental.net/minim/
 */

import processing.net.*; 
Client myClient;

 
import ddf.minim.analysis.*;
import ddf.minim.*;

Minim       minim;
AudioPlayer song;
//AudioInput in;
FFT         fft;

int[] red_vals = {
  0, 0, 0
};
int[] green_vals = {
  0, 0, 0
};
int[] blue_vals = {
  0, 0, 0
};
String rvals, gvals, bvals;
int dropTime = 0; //drop packets 
int leng;
float range1, range2, range3, range4, range5, range6, range7, range8; 
float brightness; 

void setup()
{
  size(512, 200, P3D);

  myClient = new Client(this, "127.0.0.1", 5206);
  
  minim = new Minim(this);

  // specify that we want the audio buffers of the AudioPlayer
  // to be 1024 samples long because our FFT needs to have 
  // a power-of-two buffer size and this is a good size.
  song = minim.loadFile("beat-short.mp3", 1024);
  //song = minim.loadFile("Neon Cathedral.mp3", 2048);
  //in = minim.getLineIn(Minim.MONO, 4096, 44100);
  
  // loop the file indefinitely
  song.loop();

  // create an FFT object that has a time-domain buffer 
  // the same size as song's sample buffer
  // note that this needs to be a power of two 
  // and that it means the size of the spectrum will be half as large.
  fft = new FFT( song.bufferSize(), song.sampleRate() );
  //fft = new FFT( in.left.size(), 44100 );
}

void draw()
{
  background(0);
  //stroke(255);

  // perform a forward FFT on the samples in song's mix buffer,
  // which contains the mix of both the left and right channels of the file
  fft.forward( song.mix );
  //fft.forward( in.left );
  leng = fft.specSize();

  range1 = leng/9.0;
  range2 = (2*leng)/9.0;
  range3 = leng/3.0;
  range4 = (4*leng)/9.0;
  range5 = (5*leng)/9.0;
  range6 = (2*leng)/3.0;
  range7 = (7*leng)/9.0;
  range8 = (8*leng)/9.0;

  for (int i = 0; i < leng; i++)
  {
    if (i >= 0 && i < (leng/6))
    {
      if (fft.calcAvg(0.0, range1) > fft.calcAvg(range1, range2) && fft.calcAvg(0.0, range1) > fft.calcAvg(range2, range3))
      {
        stroke(0, 0, 255);
        blue_vals[0] = 0;
        blue_vals[1] = 0;
        blue_vals[2] = 255;
      } else if (fft.calcAvg(0.0, range1) < fft.calcAvg(range1, range2) && fft.calcAvg(range1, range2) > fft.calcAvg(range2, range3))
      {
        stroke(0, 255, 255);
        blue_vals[0] = 0;
        blue_vals[1] = 255;
        blue_vals[2] = 255;
      } else 
      {
        stroke(65, 105, 225);
        blue_vals[0] = 65;
        blue_vals[1] = 105;
        blue_vals[2] = 225;
      }
    } else if (i >= (leng/6) && i < (leng/3))
    {
      if (fft.calcAvg(range3, range4) > fft.calcAvg(range4, range5) && fft.calcAvg(range3, range4) > fft.calcAvg(range5, range6))
      {
        stroke(0, 255, 0);
        green_vals[0] = 0;
        green_vals[1] = 255;
        green_vals[2] = 0;
      } else if (fft.calcAvg(range3, range4) < fft.calcAvg(range4, range5) && fft.calcAvg(range4, range5) > fft.calcAvg(range5, range6))
      {
        stroke(127, 255, 212);
        green_vals[0] = 127;
        green_vals[1] = 255;
        green_vals[2] = 212;
      } else 
      {
        stroke(0, 255, 0);
        green_vals[0] = 0;
        green_vals[1] = 255;
        green_vals[2] = 0;
      }
    } else
    {
      if (fft.calcAvg(range6, range7) > fft.calcAvg(range7, range8) && fft.calcAvg(range6, range7) > fft.calcAvg(range8, leng))
      {
        stroke(255, 0, 0);
        red_vals[0] = 255;
        red_vals[1] = 0;
        red_vals[2] = 0;
      } else if (fft.calcAvg(range6, range7) < fft.calcAvg(range7, range8) && fft.calcAvg(range7, range8) > fft.calcAvg(range8, leng))
      {
        stroke(255, 0, 255);
        red_vals[0] = 255;
        red_vals[1] = 0;
        red_vals[2] = 255;
      } else 
      {
        stroke(255, 20, 147);
        red_vals[0] = 255;
        red_vals[1] = 20;
        red_vals[2] = 147;
      }
    }

    // draw the line for frequency band i, scaling it up a bit so we can see it
    line( i, height, i, height - fft.getBand(i)*8 );
    //println(red_vals[0] + "," +  red_vals[1] + "," + red_vals[2]);
  }

  //base amplitude calibration needed for each song
  brightness = constrain(fft.calcAvg(0, range2)/10, 0.1, 1);
  //println(fft.calcAvg(0,range1));
  //println(brightness);
  
  for (int j = 0; j < 3; j++)
  {
    red_vals[j] = int(red_vals[j]*brightness);
    green_vals[j] = int(green_vals[j]*brightness);
    blue_vals[j] = int(blue_vals[j]*brightness);
  }
  rvals = "0," + red_vals[0] + "," +  red_vals[1] + "," + red_vals[2];
  gvals = "1," + green_vals[0] + "," +  green_vals[1] + "," + green_vals[2];
  bvals = "2," + blue_vals[0] + "," +  blue_vals[1] + "," + blue_vals[2];
  ;

  //println(vals);
  if (dropTime == 1){
    myClient.write(rvals + ", 90, 90");
    //myClient.write(gvals + ", 90, 90");
    //myClient.write(bvals + ", 90, 90");
    dropTime = 0;
  }
  dropTime++;
}

int[] rReturn()
{
  return red_vals;
}
int[] gReturn()
{
  return green_vals;
}
int[] bReturn()
{
  return blue_vals;
}

void stop()
{
  // always close Minim audio classes when you are done with them
  song.close();
  //in.close();
  minim.stop();

  super.stop();
}
